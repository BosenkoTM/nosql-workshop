# Начало работы с Redis

В этом воркшопе изучим основы работы с Redis. Будем использовать `Docker` для инициализации `Redis` в контейнере.

## Что такое Redis

Redis (Remote Dictionary Server) — это высокопроизводительная in-memory структура данных, используемая как база данных, кэш и брокер сообщений. Redis хранит данные в оперативной памяти, что обеспечивает очень высокую скорость доступа к данным.

### Основные характеристики Redis:
- **In-memory хранение**: все данные хранятся в оперативной памяти
- **Персистентность**: поддержка сохранения данных на диск
- **Атомарные операции**: гарантия целостности при выполнении команд
- **Репликация**: поддержка master-slave архитектуры
- **Высокая доступность**: Redis Sentinel для мониторинга
- **Кластеризация**: горизонтальное масштабирование
- **Pub/Sub**: система публикации/подписки на сообщения

### Области применения Redis:
- **Кэширование**: ускорение работы веб-приложений
- **Сессии пользователей**: хранение состояния в веб-приложениях
- **Очереди задач**: асинхронная обработка заданий
- **Лидерборды**: рейтинги в играх и приложениях
- **Геопространственные данные**: работа с координатами
- **Аналитика в реальном времени**: счетчики, метрики
- **Чат-приложения**: обмен сообщениями в реальном времени

## Использование утилиты командной строки Redis

Для подключения к `Redis` можно использовать либо утилиту командной строки `Redis`, либо браузерный `Redis Commander`.

### Использование утилиты командной строки Redis

Откройте еще одно окно терминала и введите следующую команду, чтобы запустить `Redis CLI` в другом docker-контейнере:

```bash
docker run -it --rm --network nosql-platform bitnami/redis redis-cli -h redis-1 -p 6379
```

Должен запуститься `Redis CLI` и появиться следующая командная строка (при этом IP-адрес может отличаться).

```bash
Unable to find image 'bitnami/redis:latest' locally
latest: Pulling from bitnami/redis
ce4f4d45406a: Pull complete 
Digest: sha256:25bf63f3caf75af4628c0dfcf39859ad1ac8abe135be85e99699f9637b16dc28
Status: Downloaded newer image for bitnami/redis:latest
redis 19:43:01.24 INFO  ==> 
redis 19:43:01.24 INFO  ==> Welcome to the Bitnami redis container
redis 19:43:01.25 INFO  ==> Subscribe to project updates by watching https://github.com/bitnami/containers
redis 19:43:01.25 INFO  ==> NOTICE: Starting August 28th, 2025, only a limited subset of images/charts will remain available for free. Backup will be available for some time at the 'Bitnami Legacy' repository. More info at https://github.com/bitnami/containers/issues/83267
redis 19:43:01.25 INFO  ==> 

redis-1:6379> 
```

Redis настроен так, что требует аутентификации. Вы можете использовать пользователя `default`, поэтому нужно передать только пароль с помощью команды `AUTH`.

```bash
AUTH abc123!
```

В случае появления:

```bash
ERR AUTH <password> called without any password configured for the default user означает, что сервер Redis, к которому вы подключились, не настроен на использование пароля.
```
сервер `Redis`, к которому подключились, не настроен на использование пароля.

Пропустите этот шаг. Не вводите команду `AUTH abc123!`.

Сразу после подключения через `Docker` вы уже находитесь в командной строке `Redis` и можете начать выполнять команды.

Для проверки соединения введите простую команду `PING`:

```bash
redis-1:6379> PING
```

Введите `help`, чтобы увидеть версию установленного `Redis`.

```bash
redis:6379> help
redis-cli 6.0.9
To get help about Redis commands type:
      "help @<group>" to get a list of commands in <group>
      "help <command>" for help on <command>
      "help <tab>" to get a list of possible help topics
      "quit" to exit

To set redis-cli preferences:
      ":set hints" enable online hints
      ":set nohints" disable online hints
Set your preferences in ~/.redisclirc
```

### Использование Redis Commander

В окне веб-браузера перейдите по адресу http://localhost:28119. Вы должны увидеть изображение, что показано ниже.

![Redis Commander](./images/redis-commander-home_01.png)

## Структура данных "Строка" (String)

Введите команды. Это можно сделать как с помощью `Redis CLI`, так и через `Redis Commander`.

```bash
help @string
```

### `help @string`

По сути, это главная шпаргалка по всем возможным действиям с простыми парами «ключ-значение» в `Redis`.

Эти команды можно условно разделить на несколько групп:

*   **Базовые операции:**
    *   `SET`: установить или перезаписать значение ключа.
    *   `GET`: получить значение по ключу.
    *   `DEL` (не в этом списке, но относится сюда): удалить ключ.

*   **Атомарные операции с числами:**
    *   `INCR`: увеличить числовое значение на 1.
    *   `DECR`: уменьшить числовое значение на 1.
    *   `INCRBY` / `DECRBY`: увеличить/уменьшить на заданное число.

*   **Массовые (атомарные) операции:**
    *   `MGET`: получить значения сразу нескольких ключей.
    *   `MSET`: установить значения сразу для нескольких ключей.

*   **Условные операции:**
    *   `SETNX`: установить значение, только если ключ еще не существует.

*   **Операции с частями строк:**
    *   `APPEND`: дописать строку в конец существующего значения.
    *   `GETRANGE`: получить часть (подстроку) из значения.

Этот список — основной инструмент для работы со строковыми данными в Redis.

###	Работа с ключами

`Redis` — это так называемое хранилище типа «ключ-значение», часто называемое `NoSQL` базой данных. Суть хранилища «ключ-значение» заключается в возможности сохранить некоторые данные, называемые значением, внутри ключа. Эти данные позже можно извлечь, только если мы знаем точный ключ, использованный для их сохранения.

Можно использовать команду `SET` для сохранения значения “redis-server” по ключу “server:name”:


```bash
SET server:name "redis-server"
```

`Redis` сохранит данные на постоянной основе, поэтому позже  можем спросить: «Какое значение хранится по ключу server:name?»

```bash
GET server:name 
```

и `Redis` ответит “redis-server”.

```bash
EXISTS server:name
(integer) 1
```

```bash
KEYS server*
1) "server:name"
```

```bash
KEYS *
1) "server:name"
```

### Операции Get и Set

Другие распространенные операции, предоставляемые хранилищами «ключ-значение», это `DEL` для удаления заданного ключа и связанного с ним значения, `SET-if-not-exists` (в Redis называется `SETNX`), которая устанавливает ключ, только если он еще не существует, и `INCR` для атомарного увеличения числа, хранящегося по заданному ключу. Давайте посмотрим на некоторые из этих команд в действии:

Сначала установим значение для ключа `connections` с помощью команды `SET`:

```bash
redis:6379> SET connections 10
OK
```

Проверим значение с помощью команды `GET`:

```bash
redis:6379> GET connections
"10"
```

Поробуем перезаписать его с помощью другой команды `SET`:

```bash
redis:6379> SET connections 20
OK
redis:6379> GET connections
"20"
```

Посмотрим, что произойдет, если использовать команду `SETNX`.

```bash
redis:6379> SETNX connections 30
(integer) 0
redis:6379> GET connections
"20"
```

Если  используем `SETNX` для ключа, который еще не существует, получим другой ответ:

```bash
redis:6379> SETNX newkey 30
(integer) 1
```

Используем `MSET` для установки нескольких пар «ключ-значение»...

```bash
redis:6379> MSET key1 10 key2 20 key3 30
(integer) 1
```

...и обратную команду `MGET`, чтобы получить несколько значений для нескольких ключей.

```bash
redis:6379> MGET key1 key3
1) "10"
2) "30"
```
**Примечание**: это сильно отличается от одиночных команд `SET` и `GET`, так как выполняется атомарно в одной операции.

### Операции инкремента и декремента

Рассмотрим значение как счетчик.

Инициализируем значение `connections` равным `10`, а затем используем `INCR`, чтобы увеличить его на единицу.
 
```bash
redis:6379> SET connections 10
OK
redis:6379> INCR connections 
(integer) 11
```

Видим, что в ответ получаем новое значение счетчика.

Увеличим его на `10`, используя команду `INCRBY`.

```bash
redis:6379> INCRBY connections 10
(integer) 21
```

Выполним обратную операцию: уменьшим значение счетчика. С помощью команды `DECR` счетчик уменьшается на единицу.

```bash
redis:6379> DECR connections
(integer) 20
```

А затем с помощью `DECRBY` укажем величину, на которую уменьшим значение ключа( используем 10).

```bash
redis:6379> DECRBY connections 10
(integer) 10
```
Удалим пару «ключ-значение» и посмотрим, что произойдет, если используем `INCR` для несуществующего ключа.

```bash
redis:6379> DEL connections
(integer) 1

redis:6379> EXISTS connections
(integer) 0

redis:6379> INCR connections
(integer) 1
```
Мы видим, что `INCR` автоматически начинает со значения `0` и увеличивает его на `1`, что и является результатом, который получили.

----
**Примечание**: в команде `INCR` есть особенность. Зачем  такая операция, если можно сделать это с помощью небольшого кода? В конце концов, это так же просто, как:

```bash
x = GET count
x = x + 1
SET count x
```

Проблема в том, что увеличение значения таким способом будет работать только до тех пор, пока ключ использует один клиент. Посмотрите, что произойдет, если два клиента обращаются к этому ключу одновременно:

1. Клиент А считывает `count` как 10.
2. Клиент Б считывает `count` как 10.
3. Клиент А увеличивает 10 и устанавливает `count` в 11.
4. Клиент Б увеличивает 10 и устанавливает `count` в 11.

Старались, чтобы значение стало 12, а вместо этого оно равно 11! Это происходит потому, что увеличение значения таким способом не является атомарной операцией. Вызов команды `INCR` в `Redis` помогает превратить и подтвердить, что операция атомарна. `Redis` предоставляет множество таких атомарных операций для различных типов данных.

----

### Срок действия (Expiration) и время жизни (TTL)

В `Redis` можно указать, что ключ должен существовать только в течение определенного времени. Это достигается с помощью команд `EXPIRE` и `TTL`.

Сначала установим новую пару «ключ-значение».

```bash
redis:6379> SET resource:lock "Redis Demo"
OK
```

А затем установим срок его действия в 2 минуты (120 секунд) с помощью команды `EXPIRE`.

```bash
redis:6379> EXPIRE resource:lock 120
(integer) 1
```

Это устанавливает, что ключ `resource:lock` будет удален через 120 секунд. Можно проверить, как долго ключ будет существовать, с помощью команды `TTL`. Она возвращает количество секунд до его удаления.

```bash
redis:6379> TTL resource:lock
(integer) 96
```

Подождав 96 секунд и выполнив ту же команду снова, видим, что он был удален.

```bash
redis:6379> TTL resource:lock
(integer) -2
```

Значение -2 для TTL ключа означает, что ключ (больше) не существует. Проверяем с помощью команды `EXISTS`.


```bash
redis:6379> EXISTS resource:lock
(integer) 0
```

Если вы `SET`-ите новое значение для ключа, его TTL будет сброшен. Создать значение сразу со сроком действия. Это можно сделать либо с помощью специальной команды `SETEX`, либо с помощью `SET` и опции `EX`.

```bash
redis:6379> SET resource:lock "Redis Demo 1" EX 120
OK
```

Мы видим, что время жизни было установлено при создании.

```bash
redis:6379> TTL resource:lock
(integer) 119
```

Теперь используем команду `SET`, чтобы обновить значение.

```bash
redis:6379> SET resource:lock "Redis Demo 2"
OK
```

Мы видим, что время жизни было сброшено.

```bash
redis:6379> TTL resource:lock
(integer) -1
```

Полный список [команд для строк](https://redis.io/commands#string) смотрите для получения дополнительной информации.

##	Структуры данных "Список" (List)

`Redis` также поддерживает несколько более сложных структур данных. Первая структура, которую рассмотрим, это список. 

**Список** — это серия упорядоченных значений. Некоторые из важных команд для взаимодействия со списками — это `RPUSH`, `LPUSH`, `LLEN`, `LRANGE`, `LPOP` и `RPOP`. Можно сразу начать работать с ключом как со списком, если он еще не существует как другой тип.

`RPUSH` добавляет новое значение в конец списка.

Добавить новый элемент в конец несуществующего списка с именем `skills` с помощью команды `RPUSH`.

```bash
redis:6379> RPUSH skills "Oracle RDBMS"
(integer) 1
```
Мы видим, что теперь список содержит 1 элемент. Давайте добавим еще один навык в список `skills`.


```bash
redis:6379> RPUSH skills "Redis"
(integer) 2
```

Теперь посмотрим на значения, которые в данный момент находятся в списке `skills`. Можем использовать команду `GET`?

```bash
redis:6379> GET skills
(error) WRONGTYPE Operation against a key holding the wrong kind of value
```

Команда `GET` относится к группе `String` и не может быть использована для структур `list`.
В таком случае используют команду `LRANGE`.

```bash
redis:6379> LRANGE skills 0 -1
1) "Oracle RDBMS"
2) "Redis"
``` 

`LPUSH` добавляет новое значение в начало списка.

```bash
redis:6379> LPUSH skills "SQL Server"
(integer) 3
redis:6379> LRANGE skills 0 -1
1) "SQL Server"
2) "Oracle RDBMS"
3) "Redis"
```

`LRANGE` возвращает подмножество списка. Она принимает индекс первого элемента, который требуется получить, в качестве первого параметра, и индекс последнего элемента, который требуется получить, в качестве второго параметра. Значение -1 для второго параметра означает получение элементов до конца списка.

```bash
redis:6379> LRANGE skills 0 -1 
1) "SQL Server"
2) "Oracle RDBMS"
3) "Redis"
```

```bash
redis:6379> LRANGE skills 0 1 
1) "SQL Server"
2) "Oracle RDBMS"
```

```bash
redis:6379> LRANGE skills 1 2 
2) "Oracle RDBMS"
3) "Redis"
```

`LLEN` возвращает текущую длину списка.

```bash
redis:6379> LLEN skills 
(integer) 3
```

`LPOP` удаляет первый элемент из списка и возвращает его.

```bash
redis:6379> LPOP skills 
"SQL Server"
```

`RPOP` удаляет последний элемент из списка и возвращает его.

```bash
redis:6379> RPOP skills 
"Redis"
```

**Примечание**: теперь в списке остался только один элемент:

```bash
redis:6379> LLEN skills 
(integer) 1
redis:6379> LRANGE skills 0 -1
2) "Oracle RDBMS"
```

Полный список [команд для списков](https://redis.io/commands#list).

## Структуры данных "Множество" (Set)

Следующая структура данных, которую рассмотрим, это множество.

Множество похоже на список, за исключением того, что оно не имеет определенного порядка, и каждый элемент может встречаться только один раз. Некоторые из важных команд для работы с множествами — это `SADD`, `SREM`, `SISMEMBER`, `SMEMBERS` и `SUNION`.

`SADD` добавляет заданное значение в множество.

```bash
redis:6379> SADD nosql:products "Cassandra"
(integer) 1
redis:6379> SADD nosql:products "Redis"
(integer) 1
redis:6379> SADD nosql:products "MongoDB"
(integer) 1
```

`SMEMBERS` возвращает список всех элементов этого множества.

```bash
redis:6379> SMEMBERS nosql:products
1) "Redis"
2) "Cassandra"
3) "MongoDB"
```

`SREM` удаляет заданное значение из множества.


```bash
redis:6379> SREM nosql:products "MongoDB"
(integer) 1
redis:6379> SMEMBERS nosql:products
1) "Redis"
2) "Cassandra"
```

`SISMEMBER` проверяет, находится ли заданное значение в множестве.

```bash
redis:6379> SISMEMBER nosql:products "Cassandra"
(integer) 1
redis:6379> SISMEMBER nosql:products "MongoDB"
(integer) 0
```

`Сassandra` является элементом `nosql:products`, а `MongoDB` — нет (поэтому результат 0).

`SUNION` объединяет два или более множества и возвращает список всех элементов.

Сначала создадим еще одно множество продуктов `RDBMS`:

```bash
redis:6379> SADD rdbms:products "Oracle"
(integer) 1
redis:6379> SADD rdbms:products "SQL Server"
(integer) 1
```

Теперь создадим объединение двух множеств:

```bash
redis:6379> SUNION rdbms:products nosql:products
1) "SQL Server"
2) "Cassandra"
3) "Redis"
4) "Oracle"
```

`SUNIONSTORE` объединяет два или более множества и сохраняет результат в новое множество.

```bash
redis:6379> SUNIONSTORE database:products rdbms:products nosql:products
(integer) 4
redis:6379> SMEMBERS database:products
1) "SQL Server"
2) "Cassandra"
3) "Redis"
4) "Oracle"
```

`SINTER` находит пересечение двух или более множеств и возвращает список пересекающихся элементов.

```bash
redis:6379> SADD favorite:products "Cassandra"
(integer) 1
redis:6379> SADD favorite:products "Oracle"
(integer) 1

redis:6379> SINTER database:products favorite:products
1) "Cassandra"
2) "Oracle"
```

Полный список [команд для множеств](https://redis.io/commands#set).

   
## Структуры данных "Упорядоченное множество" (Sorted Set)

Множества — очень удобный тип данных, но поскольку они неупорядочены, они плохо подходят для решения ряда задач. Именно поэтому в `Redis 1.2` были введены упорядоченные множества.
Упорядоченное множество похоже на обычное, но теперь каждое значение связано с оценкой (score). Эта оценка используется для сортировки элементов в множестве.

`ZADD` добавляет один или несколько элементов в упорядоченное множество.

```bash
redis:6379> ZADD pioneers 1940 "Alan Kay"
(integer) 1
redis:6379> ZADD pioneers 1906 "Grace Hopper"
(integer) 1
redis:6379> ZADD pioneers 1953 "Richard Stallman"
(integer) 1
redis:6379> ZADD pioneers 1965 "Yukihiro Matsumoto"
(integer) 1
redis:6379> ZADD pioneers 1916 "Claude Shannon"
(integer) 1
redis:6379> ZADD pioneers 1969 "Linus Torvalds"
(integer) 1
redis:6379> ZADD pioneers 1957 "Sophie Wilson"
(integer) 1
redis:6379> ZADD pioneers 1912 "Alan Turing"
(integer) 1
```

В этих примерах `оценки` — это год рождения, а `значения` — имена известных людей в информатике.

`ZRANGE` возвращает диапазон элементов в упорядоченном множестве по индексу (отсортировано от меньшего к большему, т.е. по возрастанию), опционально также возвращает оценки. Индекс начинается с 0.

```bash
redis:6379> ZRANGE pioneers 2 4
1) "Claude Shannon"
2) "Alan Kay"
3) "Richard Stallman"

redis:6379> ZRANGE pioneers 2 4 WITHSCORES
1) "Claude Shannon"
2) "1916"
3) "Alan Kay"
4) "1940"
5) "Richard Stallman"
6) "1953"
```

`ZREVRANGE` возвращает диапазон элементов в упорядоченном множестве по индексу (отсортировано от большего к меньшему, т.е. по убыванию), опционально также возвращает оценки. Индекс начинается с 0.

```bash
redis:6379> ZREVRANGE pioneers 0 2
1) "Linus Torvalds"
2) "Yukihiro Matsumoto"
3) "Sophie Wilson"
```

Полный список [команд для упорядоченных множеств](https://redis.io/commands#sorted_set).

## Структуры данных "Хэш" (Hash)

Простые строки, множества и упорядоченные множества уже позволяют многое сделать, но есть еще один тип данных, с которым может работать Redis: хэши.

Хэши — это карты (соответствия) между строковыми полями и строковыми значениями, поэтому они являются идеальным типом данных для представления объектов (например, пользователя и его поля-идентификаторы, таких как имя, фамилия, возраст и т.д.):

`HSET` устанавливает значение для поля в хэше, хранящемся по заданному ключу.

```bash
redis:6379> HSET user:1000 name "John Smith"
(integer) 1
redis:6379> HSET user:1000 email "john.smith@example.com"
(integer) 1
redis:6379> HSET user:1000 password "s3cret"
(integer) 1
```

Чтобы получить сохраненные данные, используйте команду `HGETALL`:

```bash
redis:6379> HGETALL user:1000
1) "name"
2) "John Smith"
3) "email"
4) "john.smith@example.com"
5) "password"
6) "s3cret"
```

Вы также можете установить несколько полей одновременно с помощью команды `HMSET`. 

```bash
redis:6379> HMSET user:1001 name "Mary Jones" password "hidden" email "mjones@example.com"
OK
```

Давайте убедимся, что это сработало и был создан новый хэш.

```bash
redis:6379> HGETALL user:1001
1) "name"
2) "Mary Jones"
3) "password"
4) "hidden"
5) "email"
6) "mjones@example.com"
```

Если требуется получить значение только одного поля, это также возможно с помощью команды HGET.

```bash
redis:6379> HGET user:1001 name
"Mary Jones"
```

Числовые значения в полях хэша обрабатываются точно так же, как и в простых строках, и существуют операции для атомарного увеличения этого значения.

```bash
redis:6379> HSET user:1000 visits 10
(integer) 1
redis:6379> HINCRBY user:1000 visits 1
(integer) 11
redis:6379> HINCRBY user:1000 visits 10
(integer) 21
redis:6379> HDEL user:1000 visits
(integer) 1
```
Полный список [команд для хэшей](https://redis.io/commands#hash)  

## Дополнительные возможности Redis

### Геопространственные данные
Redis поддерживает работу с географическими координатами через команды GEO:

```bash
# Добавление местоположений
GEOADD cities:russia 37.6176 55.7558 "Moscow"
GEOADD cities:russia 30.3351 59.9311 "Saint Petersburg"
GEOADD cities:russia 82.9346 55.0084 "Novosibirsk"

# Поиск объектов в радиусе
GEORADIUS cities:russia 37.6176 55.7558 500 km WITHDIST

## Тестирование производительности Redis (Redis Benchmark)
Эта команда предназначена для проверки, насколько быстро сервер `Redis` может обрабатывать различные типы команд. Это полезно для оценки производительности и "прогрева" системы.

```bash
docker run -it --rm --network nosql-platform bitnami/redis redis-benchmark -h redis-1 -a "abc123!" -q -n 100000
```
Получим вывод, который показывает, сколько тысяч операций каждого типа  Redis-сервер способен обработать в секунду:

```bash
PING_INLINE: 116279.07 requests per second
PING_BULK: 114942.53 requests per second
SET: 113636.36 requests per second
GET: 114942.53 requests per second
INCR: 112359.55 requests per second
LPUSH: 114942.53 requests per second
RPUSH: 116279.07 requests per second
LPOP: 116279.07 requests per second
RPOP: 113636.36 requests per second
SADD: 116279.07 requests per second
```

## Python
Этот раздел показывает, как взаимодействовать с `Redis` не через командную строку, а программно, используя язык `Python`. Это основной способ работы с `Redis` в реальных приложениях.


1. Установка библиотеки
   
```Python
conda install redis-py
```
2. Подключение к Redis из Python
   
```Python
import redis
r = redis.Redis(host='redis', port=6379, db=0)
```

3. Проверка соединения
```Python
r.ping()
```

```Python
r.set('foo','bar')
```
**Пояснение**:

r.set('foo','bar') - выполнение команды `SET` через `Python`. Вызываем метод `.set()` у  объекта подключения `r` и передаем ему ключ `('foo')` и значение `('bar')`.

Если команда выполнена успешно, метод вернет `True`.

Полный пример для `Jupyter`:

```Python
!pip install redis
```

```Python
import redis

# Создаем подключение (используем localhost, т.к. Jupyter на хосте VM)
# decode_responses=True автоматически преобразует ответы из байтов в строки
# r = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)
r = redis.Redis(host='redis-1', port=6379, db=0, decode_responses=True)

# 1. Проверяем соединение
try:
    if r.ping():
        print("Соединение с Redis установлено!")
except redis.exceptions.ConnectionError as e:
    print(f"Не удалось подключиться к Redis: {e}")

# 2. Устанавливаем значение
key = 'message:1'
value = 'Hello from Python!'
result = r.set(key, value)
print(f"Команда SET для ключа '{key}' выполнена успешно: {result}")

# 3. Получаем значение обратно
retrieved_value = r.get(key)
print(f"Полученное значение для ключа '{key}': {retrieved_value}")

# 4. Удаляем ключ для очистки
r.delete(key)
print(f"Ключ '{key}' удален.")
```


**Результат**:

```Python
Соединение с Redis установлено!
Команда SET для ключа 'message:1' выполнена успешно: True
Полученное значение для ключа 'message:1': Hello from Python!
Ключ 'message:1' удален.
```

# 30 вариантов заданий для индивидуального выполнения на Python

## Базовые задания (варианты 1-10)

### Вариант 1: Система счетчиков посещений
Создайте систему подсчета посещений веб-страниц. Реализуйте функции для:
- Увеличения счетчика посещений страницы
- Получения количества посещений
- Получения топ-5 самых посещаемых страниц
- Сброса статистики

```python
# Пример структуры данных
# page_views:home = 150
# page_views:about = 75
```

### Вариант 2: Корзина покупок интернет-магазина
Разработайте систему управления корзиной покупок:
- Добавление товара в корзину
- Удаление товара из корзины
- Изменение количества товара
- Подсчет общей стоимости корзины
- Очистка корзины

```python
# Структура: cart:user_id = {product_id: quantity, price: value}
```

### Вариант 3: Система рейтингов товаров
Создайте систему для управления рейтингами товаров:
- Добавление оценки товару (1-5 звезд)
- Вычисление среднего рейтинга
- Получение топ-10 товаров по рейтингу
- Подсчет количества оценок

### Вариант 4: Кэш для API запросов
Реализуйте кэширующий слой для API:
- Сохранение результатов API запросов с TTL
- Проверка наличия кэшированного результата
- Инвалидация кэша
- Статистика попаданий/промахов кэша

### Вариант 5: Система уведомлений
Разработайте систему уведомлений пользователей:
- Добавление уведомления в очередь
- Получение непрочитанных уведомлений
- Отметка уведомления как прочитанного
- Удаление старых уведомлений

### Вариант 6: Лог активности пользователей
Создайте систему логирования действий пользователей:
- Запись действия пользователя с временной меткой
- Получение истории действий за период
- Подсчет активности по типам действий
- Очистка старых логов

### Вариант 7: Система голосования
Реализуйте платформу для проведения голосований:
- Создание опроса с вариантами ответов
- Голосование пользователей
- Подсчет голосов
- Защита от повторного голосования
- Получение результатов в реальном времени

### Вариант 8: Менеджер паролей
Разработайте простой менеджер паролей:
- Сохранение зашифрованных паролей
- Категоризация паролей
- Поиск паролей по названию сервиса
- Генерация отчетов о безопасности

### Вариант 9: Система бронирования
Создайте систему бронирования ресурсов:
- Создание расписания доступности
- Бронирование временных слотов
- Отмена бронирования
- Проверка конфликтов при бронировании
- Получение свободных слотов

### Вариант 10: Трекер привычек
Разработайте приложение для отслеживания привычек:
- Создание привычки с целевой частотой
- Отметка выполнения привычки
- Подсчет streak (дней подряд)
- Статистика выполнения за месяц/год
- Напоминания о невыполненных привычках

## Средние задания (варианты 11-20)

### Вариант 11: Система чата с комнатами
Реализуйте backend для чат-приложения:
- Создание/удаление чат-комнат
- Добавление пользователей в комнату
- Отправка/получение сообщений
- История сообщений (последние 100)
- Онлайн статус участников

### Вариант 12: Биржа криптовалют (упрощенная)
Создайте систему торговли криптовалютами:
- Книга заявок (order book)
- Размещение/отмена ордеров
- Сопоставление заявок на покупку/продажу
- История сделок
- Портфели пользователей

### Вариант 13: Система рекомендаций
Разработайте движок рекомендаций:
- Сохранение предпочтений пользователей
- Расчет похожести между пользователями
- Рекомендации на основе поведения
- A/B тестирование рекомендаций
- Обратная связь от пользователей

### Вариант 14: Мониторинг серверов
Создайте систему мониторинга IT-инфраструктуры:
- Сбор метрик серверов (CPU, память, диск)
- Настройка алертов при превышении порогов
- Агрегация данных по временным интервалам
- Дашборд с ключевыми показателями
- История инцидентов

### Вариант 15: Система управления контентом
Реализуйте CMS с кэшированием:
- Создание/редактирование статей
- Версионирование контента
- Кэширование рендера страниц
- Теги и категории
- Поиск по контенту

### Вариант 16: Планировщик задач
Разработайте систему планирования и выполнения задач:
- Создание задач с приоритетами
- Планирование выполнения (cron-like)
- Очереди задач по типам
- Мониторинг состояния задач
- Повторные попытки при ошибках

### Вариант 17: Система лояльности
Создайте программу лояльности для клиентов:
- Начисление баллов за покупки
- Уровни лояльности с привилегиями
- Акции и бонусные мультипликаторы
- История транзакций баллов
- Уведомления о специальных предложениях

### Вариант 18: Игровой сервер (простая MMO)
Реализуйте backend для онлайн-игры:
- Регистрация/аутентификация игроков
- Игровые сессии и состояния
- Рейтинговая система
- Достижения и прогресс
- Социальные функции (друзья, гильдии)

### Вариант 19: Система аналитики событий
Разработайте платформу для веб-аналитики:
- Трекинг пользовательских событий
- Воронки конверсии
- Когортный анализ
- Real-time дашборды
- Сегментация аудитории

### Вариант 20: Платформа онлайн-обучения
Создайте LMS (Learning Management System):
- Курсы и уроки
- Прогресс обучения студентов
- Тестирование знаний
- Сертификация
- Социальное обучение (форумы, обсуждения)

## Сложные задания (варианты 21-30)

### Вариант 21: Высокопроизводительный веб-краулер
Реализуйте распределенную систему сбора данных:
- Очередь URL для обработки
- Дедупликация ссылок
- Ограничение скорости для доменов
- Обработка robots.txt
- Мониторинг производительности

### Вариант 22: Система машинного обучения в продакшене
Создайте MLOps платформу:
- Версионирование моделей
- A/B тестирование моделей
- Мониторинг качества предсказаний
- Feature store для признаков
- Автоматическое переобучение

### Вариант 23: Биржа для торговли акциями
Разработайте полноценную торговую систему:
- Комплексные типы ордеров (stop-loss, take-profit)
- Маржинальная торговля
- Система клиринга и расчетов
- Управление рисками
- Регуляторная отчетность

### Вариант 24: Платформа для IoT данных
Создайте систему для Интернета вещей:
- Прием данных с множества устройств
- Агрегация и обработка временных рядов
- Алерты на аномалии в данных
- Управление устройствами
- Геораспределенная архитектура

### Вариант 25: Система управления цепочками поставок
Реализуйте SCM решение:
- Отслеживание товаров в цепи поставок
- Прогнозирование спроса
- Оптимизация запасов
- Интеграция с поставщиками
- Анализ рисков поставок

### Вариант 26: Платформа для финансовых данных
Разработайте систему для работы с рыночными данными:
- Получение котировок в реальном времени
- Технический анализ (индикаторы)
- Алгоритмическая торговля
- Бэктестинг стратегий
- Управление портфелем

### Вариант 27: Система видеостриминга
Создайте платформу для видеоконтента:
- Метаданные видео и управление каталогом
- Персонализированные рекомендации
- Система комментариев и рейтингов
- Аналитика просмотров
- Монетизация контента

### Вариант 28: Платформа электронной коммерции (Enterprise)
Реализуйте комплексное решение для e-commerce:
- Каталог товаров с фасетным поиском
- Динамическое ценообразование
- Система промокодов и скидок
- Мультирегиональность и валюты
- Интеграция с внешними сервисами

### Вариант 29: Система управления знаниями
Разработайте корпоративную базу знаний:
- Полнотекстовый поиск документов
- Семантическое связывание контента
- Коллаборативное редактирование
- Система экспертизы и одобрения
- Аналитика использования знаний

### Вариант 30: Платформа для больших данных
Создайте систему обработки Big Data:
- Потоковая обработка данных (streaming)
- Распределенные вычисления
- Оптимизация запросов
- Управление схемами данных
- Интеграция с Hadoop экосистемой

## Общие требования для всех вариантов

### Технические требования:
- Использование библиотеки `redis-py`
- Обработка ошибок подключения
- Использование connection pooling
- Логирование операций
- Юнит-тесты для основных функций

### Документация:
- README.md с описанием проекта
- Документация API (если применимо)
- Схема данных в Redis
- Инструкции по развертыванию

### Дополнительные задачи (по выбору):
- Реализация веб-интерфейса (Flask/FastAPI)
- Docker-контейнеризация
- CI/CD pipeline
- Мониторинг производительности
- Интеграция с внешними API

### Критерии оценки:
1. **Функциональность** (40%): соответствие требованиям задания
2. **Качество кода** (25%): читаемость, структура, следование best practices
3. **Тестирование** (15%): покрытие тестами, качество тестов
4. **Документация** (10%): полнота и качество документации
5. **Дополнительные возможности** (10%): креативные улучшения, производительность

### Сроки выполнения:
- Простые задания (1-10): 1-2 недели
- Средние задания (11-20): 2-3 недели  
- Сложные задания (21-30): 3-4 недели

























